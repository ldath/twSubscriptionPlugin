<?php


/**
 * Base class that represents a query for the 'tw_subscription_list' table.
 *
 * 
 *
 * This class was autogenerated by Propel 1.6.6 on:
 *
 * Thu Sep 27 23:40:08 2012
 *
 * @method     twSubscriptionListQuery orderById($order = Criteria::ASC) Order by the id column
 * @method     twSubscriptionListQuery orderByTypeId($order = Criteria::ASC) Order by the type_id column
 * @method     twSubscriptionListQuery orderByTemplateId($order = Criteria::ASC) Order by the template_id column
 * @method     twSubscriptionListQuery orderByListname($order = Criteria::ASC) Order by the listname column
 * @method     twSubscriptionListQuery orderByListdesc($order = Criteria::ASC) Order by the listdesc column
 * @method     twSubscriptionListQuery orderByFromname($order = Criteria::ASC) Order by the fromname column
 * @method     twSubscriptionListQuery orderByMailfrom($order = Criteria::ASC) Order by the mailfrom column
 * @method     twSubscriptionListQuery orderBySmtphost($order = Criteria::ASC) Order by the smtphost column
 * @method     twSubscriptionListQuery orderBySmtpport($order = Criteria::ASC) Order by the smtpport column
 * @method     twSubscriptionListQuery orderBySmtpencr($order = Criteria::ASC) Order by the smtpencr column
 * @method     twSubscriptionListQuery orderBySmtpuser($order = Criteria::ASC) Order by the smtpuser column
 * @method     twSubscriptionListQuery orderBySmtppass($order = Criteria::ASC) Order by the smtppass column
 * @method     twSubscriptionListQuery orderByWebsiteBaseUrl($order = Criteria::ASC) Order by the website_base_url column
 * @method     twSubscriptionListQuery orderByWebsiteSharedKey($order = Criteria::ASC) Order by the website_shared_key column
 * @method     twSubscriptionListQuery orderByLastsyncAt($order = Criteria::ASC) Order by the lastsync_at column
 *
 * @method     twSubscriptionListQuery groupById() Group by the id column
 * @method     twSubscriptionListQuery groupByTypeId() Group by the type_id column
 * @method     twSubscriptionListQuery groupByTemplateId() Group by the template_id column
 * @method     twSubscriptionListQuery groupByListname() Group by the listname column
 * @method     twSubscriptionListQuery groupByListdesc() Group by the listdesc column
 * @method     twSubscriptionListQuery groupByFromname() Group by the fromname column
 * @method     twSubscriptionListQuery groupByMailfrom() Group by the mailfrom column
 * @method     twSubscriptionListQuery groupBySmtphost() Group by the smtphost column
 * @method     twSubscriptionListQuery groupBySmtpport() Group by the smtpport column
 * @method     twSubscriptionListQuery groupBySmtpencr() Group by the smtpencr column
 * @method     twSubscriptionListQuery groupBySmtpuser() Group by the smtpuser column
 * @method     twSubscriptionListQuery groupBySmtppass() Group by the smtppass column
 * @method     twSubscriptionListQuery groupByWebsiteBaseUrl() Group by the website_base_url column
 * @method     twSubscriptionListQuery groupByWebsiteSharedKey() Group by the website_shared_key column
 * @method     twSubscriptionListQuery groupByLastsyncAt() Group by the lastsync_at column
 *
 * @method     twSubscriptionListQuery leftJoin($relation) Adds a LEFT JOIN clause to the query
 * @method     twSubscriptionListQuery rightJoin($relation) Adds a RIGHT JOIN clause to the query
 * @method     twSubscriptionListQuery innerJoin($relation) Adds a INNER JOIN clause to the query
 *
 * @method     twSubscriptionListQuery leftJointwSubscriptionListType($relationAlias = null) Adds a LEFT JOIN clause to the query using the twSubscriptionListType relation
 * @method     twSubscriptionListQuery rightJointwSubscriptionListType($relationAlias = null) Adds a RIGHT JOIN clause to the query using the twSubscriptionListType relation
 * @method     twSubscriptionListQuery innerJointwSubscriptionListType($relationAlias = null) Adds a INNER JOIN clause to the query using the twSubscriptionListType relation
 *
 * @method     twSubscriptionListQuery leftJointwSubscriptionTemplate($relationAlias = null) Adds a LEFT JOIN clause to the query using the twSubscriptionTemplate relation
 * @method     twSubscriptionListQuery rightJointwSubscriptionTemplate($relationAlias = null) Adds a RIGHT JOIN clause to the query using the twSubscriptionTemplate relation
 * @method     twSubscriptionListQuery innerJointwSubscriptionTemplate($relationAlias = null) Adds a INNER JOIN clause to the query using the twSubscriptionTemplate relation
 *
 * @method     twSubscriptionListQuery leftJointwSubscriptionEmail($relationAlias = null) Adds a LEFT JOIN clause to the query using the twSubscriptionEmail relation
 * @method     twSubscriptionListQuery rightJointwSubscriptionEmail($relationAlias = null) Adds a RIGHT JOIN clause to the query using the twSubscriptionEmail relation
 * @method     twSubscriptionListQuery innerJointwSubscriptionEmail($relationAlias = null) Adds a INNER JOIN clause to the query using the twSubscriptionEmail relation
 *
 * @method     twSubscriptionListQuery leftJointwSubscriptionListInvitation($relationAlias = null) Adds a LEFT JOIN clause to the query using the twSubscriptionListInvitation relation
 * @method     twSubscriptionListQuery rightJointwSubscriptionListInvitation($relationAlias = null) Adds a RIGHT JOIN clause to the query using the twSubscriptionListInvitation relation
 * @method     twSubscriptionListQuery innerJointwSubscriptionListInvitation($relationAlias = null) Adds a INNER JOIN clause to the query using the twSubscriptionListInvitation relation
 *
 * @method     twSubscriptionListQuery leftJointwSubscriptionMailing($relationAlias = null) Adds a LEFT JOIN clause to the query using the twSubscriptionMailing relation
 * @method     twSubscriptionListQuery rightJointwSubscriptionMailing($relationAlias = null) Adds a RIGHT JOIN clause to the query using the twSubscriptionMailing relation
 * @method     twSubscriptionListQuery innerJointwSubscriptionMailing($relationAlias = null) Adds a INNER JOIN clause to the query using the twSubscriptionMailing relation
 *
 * @method     twSubscriptionListQuery leftJointwSubscriptionMailQueue($relationAlias = null) Adds a LEFT JOIN clause to the query using the twSubscriptionMailQueue relation
 * @method     twSubscriptionListQuery rightJointwSubscriptionMailQueue($relationAlias = null) Adds a RIGHT JOIN clause to the query using the twSubscriptionMailQueue relation
 * @method     twSubscriptionListQuery innerJointwSubscriptionMailQueue($relationAlias = null) Adds a INNER JOIN clause to the query using the twSubscriptionMailQueue relation
 *
 * @method     twSubscriptionList findOne(PropelPDO $con = null) Return the first twSubscriptionList matching the query
 * @method     twSubscriptionList findOneOrCreate(PropelPDO $con = null) Return the first twSubscriptionList matching the query, or a new twSubscriptionList object populated from the query conditions when no match is found
 *
 * @method     twSubscriptionList findOneById(int $id) Return the first twSubscriptionList filtered by the id column
 * @method     twSubscriptionList findOneByTypeId(int $type_id) Return the first twSubscriptionList filtered by the type_id column
 * @method     twSubscriptionList findOneByTemplateId(int $template_id) Return the first twSubscriptionList filtered by the template_id column
 * @method     twSubscriptionList findOneByListname(string $listname) Return the first twSubscriptionList filtered by the listname column
 * @method     twSubscriptionList findOneByListdesc(string $listdesc) Return the first twSubscriptionList filtered by the listdesc column
 * @method     twSubscriptionList findOneByFromname(string $fromname) Return the first twSubscriptionList filtered by the fromname column
 * @method     twSubscriptionList findOneByMailfrom(string $mailfrom) Return the first twSubscriptionList filtered by the mailfrom column
 * @method     twSubscriptionList findOneBySmtphost(string $smtphost) Return the first twSubscriptionList filtered by the smtphost column
 * @method     twSubscriptionList findOneBySmtpport(int $smtpport) Return the first twSubscriptionList filtered by the smtpport column
 * @method     twSubscriptionList findOneBySmtpencr(int $smtpencr) Return the first twSubscriptionList filtered by the smtpencr column
 * @method     twSubscriptionList findOneBySmtpuser(string $smtpuser) Return the first twSubscriptionList filtered by the smtpuser column
 * @method     twSubscriptionList findOneBySmtppass(string $smtppass) Return the first twSubscriptionList filtered by the smtppass column
 * @method     twSubscriptionList findOneByWebsiteBaseUrl(string $website_base_url) Return the first twSubscriptionList filtered by the website_base_url column
 * @method     twSubscriptionList findOneByWebsiteSharedKey(string $website_shared_key) Return the first twSubscriptionList filtered by the website_shared_key column
 * @method     twSubscriptionList findOneByLastsyncAt(string $lastsync_at) Return the first twSubscriptionList filtered by the lastsync_at column
 *
 * @method     array findById(int $id) Return twSubscriptionList objects filtered by the id column
 * @method     array findByTypeId(int $type_id) Return twSubscriptionList objects filtered by the type_id column
 * @method     array findByTemplateId(int $template_id) Return twSubscriptionList objects filtered by the template_id column
 * @method     array findByListname(string $listname) Return twSubscriptionList objects filtered by the listname column
 * @method     array findByListdesc(string $listdesc) Return twSubscriptionList objects filtered by the listdesc column
 * @method     array findByFromname(string $fromname) Return twSubscriptionList objects filtered by the fromname column
 * @method     array findByMailfrom(string $mailfrom) Return twSubscriptionList objects filtered by the mailfrom column
 * @method     array findBySmtphost(string $smtphost) Return twSubscriptionList objects filtered by the smtphost column
 * @method     array findBySmtpport(int $smtpport) Return twSubscriptionList objects filtered by the smtpport column
 * @method     array findBySmtpencr(int $smtpencr) Return twSubscriptionList objects filtered by the smtpencr column
 * @method     array findBySmtpuser(string $smtpuser) Return twSubscriptionList objects filtered by the smtpuser column
 * @method     array findBySmtppass(string $smtppass) Return twSubscriptionList objects filtered by the smtppass column
 * @method     array findByWebsiteBaseUrl(string $website_base_url) Return twSubscriptionList objects filtered by the website_base_url column
 * @method     array findByWebsiteSharedKey(string $website_shared_key) Return twSubscriptionList objects filtered by the website_shared_key column
 * @method     array findByLastsyncAt(string $lastsync_at) Return twSubscriptionList objects filtered by the lastsync_at column
 *
 * @package    propel.generator.plugins.twSubscriptionPlugin.lib.model.om
 */
abstract class BasetwSubscriptionListQuery extends ModelCriteria
{
    
    /**
     * Initializes internal state of BasetwSubscriptionListQuery object.
     *
     * @param     string $dbName The dabase name
     * @param     string $modelName The phpName of a model, e.g. 'Book'
     * @param     string $modelAlias The alias for the model in this query, e.g. 'b'
     */
    public function __construct($dbName = 'propel', $modelName = 'twSubscriptionList', $modelAlias = null)
    {
        parent::__construct($dbName, $modelName, $modelAlias);
    }

    /**
     * Returns a new twSubscriptionListQuery object.
     *
     * @param     string $modelAlias The alias of a model in the query
     * @param     twSubscriptionListQuery|Criteria $criteria Optional Criteria to build the query from
     *
     * @return twSubscriptionListQuery
     */
    public static function create($modelAlias = null, $criteria = null)
    {
        if ($criteria instanceof twSubscriptionListQuery) {
            return $criteria;
        }
        $query = new twSubscriptionListQuery();
        if (null !== $modelAlias) {
            $query->setModelAlias($modelAlias);
        }
        if ($criteria instanceof Criteria) {
            $query->mergeWith($criteria);
        }

        return $query;
    }

    /**
     * Find object by primary key.
     * Propel uses the instance pool to skip the database if the object exists.
     * Go fast if the query is untouched.
     *
     * <code>
     * $obj  = $c->findPk(12, $con);
     * </code>
     *
     * @param mixed $key Primary key to use for the query 
     * @param     PropelPDO $con an optional connection object
     *
     * @return   twSubscriptionList|twSubscriptionList[]|mixed the result, formatted by the current formatter
     */
    public function findPk($key, $con = null)
    {
        if ($key === null) {
            return null;
        }
        if ((null !== ($obj = twSubscriptionListPeer::getInstanceFromPool((string) $key))) && !$this->formatter) {
            // the object is alredy in the instance pool
            return $obj;
        }
        if ($con === null) {
            $con = Propel::getConnection(twSubscriptionListPeer::DATABASE_NAME, Propel::CONNECTION_READ);
        }
        $this->basePreSelect($con);
        if ($this->formatter || $this->modelAlias || $this->with || $this->select
         || $this->selectColumns || $this->asColumns || $this->selectModifiers
         || $this->map || $this->having || $this->joins) {
            return $this->findPkComplex($key, $con);
        } else {
            return $this->findPkSimple($key, $con);
        }
    }

    /**
     * Find object by primary key using raw SQL to go fast.
     * Bypass doSelect() and the object formatter by using generated code.
     *
     * @param     mixed $key Primary key to use for the query
     * @param     PropelPDO $con A connection object
     *
     * @return   twSubscriptionList A model object, or null if the key is not found
     * @throws   PropelException
     */
    protected function findPkSimple($key, $con)
    {
        $sql = 'SELECT `ID`, `TYPE_ID`, `TEMPLATE_ID`, `LISTNAME`, `LISTDESC`, `FROMNAME`, `MAILFROM`, `SMTPHOST`, `SMTPPORT`, `SMTPENCR`, `SMTPUSER`, `SMTPPASS`, `WEBSITE_BASE_URL`, `WEBSITE_SHARED_KEY`, `LASTSYNC_AT` FROM `tw_subscription_list` WHERE `ID` = :p0';
        try {
            $stmt = $con->prepare($sql);
			$stmt->bindValue(':p0', $key, PDO::PARAM_INT);
            $stmt->execute();
        } catch (Exception $e) {
            Propel::log($e->getMessage(), Propel::LOG_ERR);
            throw new PropelException(sprintf('Unable to execute SELECT statement [%s]', $sql), $e);
        }
        $obj = null;
        if ($row = $stmt->fetch(PDO::FETCH_NUM)) {
            $obj = new twSubscriptionList();
            $obj->hydrate($row);
            twSubscriptionListPeer::addInstanceToPool($obj, (string) $key);
        }
        $stmt->closeCursor();

        return $obj;
    }

    /**
     * Find object by primary key.
     *
     * @param     mixed $key Primary key to use for the query
     * @param     PropelPDO $con A connection object
     *
     * @return twSubscriptionList|twSubscriptionList[]|mixed the result, formatted by the current formatter
     */
    protected function findPkComplex($key, $con)
    {
        // As the query uses a PK condition, no limit(1) is necessary.
        $criteria = $this->isKeepQuery() ? clone $this : $this;
        $stmt = $criteria
            ->filterByPrimaryKey($key)
            ->doSelect($con);

        return $criteria->getFormatter()->init($criteria)->formatOne($stmt);
    }

    /**
     * Find objects by primary key
     * <code>
     * $objs = $c->findPks(array(12, 56, 832), $con);
     * </code>
     * @param     array $keys Primary keys to use for the query
     * @param     PropelPDO $con an optional connection object
     *
     * @return PropelObjectCollection|twSubscriptionList[]|mixed the list of results, formatted by the current formatter
     */
    public function findPks($keys, $con = null)
    {
        if ($con === null) {
            $con = Propel::getConnection($this->getDbName(), Propel::CONNECTION_READ);
        }
        $this->basePreSelect($con);
        $criteria = $this->isKeepQuery() ? clone $this : $this;
        $stmt = $criteria
            ->filterByPrimaryKeys($keys)
            ->doSelect($con);

        return $criteria->getFormatter()->init($criteria)->format($stmt);
    }

    /**
     * Filter the query by primary key
     *
     * @param     mixed $key Primary key to use for the query
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByPrimaryKey($key)
    {

        return $this->addUsingAlias(twSubscriptionListPeer::ID, $key, Criteria::EQUAL);
    }

    /**
     * Filter the query by a list of primary keys
     *
     * @param     array $keys The list of primary key to use for the query
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByPrimaryKeys($keys)
    {

        return $this->addUsingAlias(twSubscriptionListPeer::ID, $keys, Criteria::IN);
    }

    /**
     * Filter the query on the id column
     *
     * Example usage:
     * <code>
     * $query->filterById(1234); // WHERE id = 1234
     * $query->filterById(array(12, 34)); // WHERE id IN (12, 34)
     * $query->filterById(array('min' => 12)); // WHERE id > 12
     * </code>
     *
     * @param     mixed $id The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterById($id = null, $comparison = null)
    {
        if (is_array($id) && null === $comparison) {
            $comparison = Criteria::IN;
        }

        return $this->addUsingAlias(twSubscriptionListPeer::ID, $id, $comparison);
    }

    /**
     * Filter the query on the type_id column
     *
     * Example usage:
     * <code>
     * $query->filterByTypeId(1234); // WHERE type_id = 1234
     * $query->filterByTypeId(array(12, 34)); // WHERE type_id IN (12, 34)
     * $query->filterByTypeId(array('min' => 12)); // WHERE type_id > 12
     * </code>
     *
     * @see       filterBytwSubscriptionListType()
     *
     * @param     mixed $typeId The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByTypeId($typeId = null, $comparison = null)
    {
        if (is_array($typeId)) {
            $useMinMax = false;
            if (isset($typeId['min'])) {
                $this->addUsingAlias(twSubscriptionListPeer::TYPE_ID, $typeId['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($typeId['max'])) {
                $this->addUsingAlias(twSubscriptionListPeer::TYPE_ID, $typeId['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::TYPE_ID, $typeId, $comparison);
    }

    /**
     * Filter the query on the template_id column
     *
     * Example usage:
     * <code>
     * $query->filterByTemplateId(1234); // WHERE template_id = 1234
     * $query->filterByTemplateId(array(12, 34)); // WHERE template_id IN (12, 34)
     * $query->filterByTemplateId(array('min' => 12)); // WHERE template_id > 12
     * </code>
     *
     * @see       filterBytwSubscriptionTemplate()
     *
     * @param     mixed $templateId The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByTemplateId($templateId = null, $comparison = null)
    {
        if (is_array($templateId)) {
            $useMinMax = false;
            if (isset($templateId['min'])) {
                $this->addUsingAlias(twSubscriptionListPeer::TEMPLATE_ID, $templateId['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($templateId['max'])) {
                $this->addUsingAlias(twSubscriptionListPeer::TEMPLATE_ID, $templateId['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::TEMPLATE_ID, $templateId, $comparison);
    }

    /**
     * Filter the query on the listname column
     *
     * Example usage:
     * <code>
     * $query->filterByListname('fooValue');   // WHERE listname = 'fooValue'
     * $query->filterByListname('%fooValue%'); // WHERE listname LIKE '%fooValue%'
     * </code>
     *
     * @param     string $listname The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByListname($listname = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($listname)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $listname)) {
                $listname = str_replace('*', '%', $listname);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::LISTNAME, $listname, $comparison);
    }

    /**
     * Filter the query on the listdesc column
     *
     * Example usage:
     * <code>
     * $query->filterByListdesc('fooValue');   // WHERE listdesc = 'fooValue'
     * $query->filterByListdesc('%fooValue%'); // WHERE listdesc LIKE '%fooValue%'
     * </code>
     *
     * @param     string $listdesc The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByListdesc($listdesc = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($listdesc)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $listdesc)) {
                $listdesc = str_replace('*', '%', $listdesc);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::LISTDESC, $listdesc, $comparison);
    }

    /**
     * Filter the query on the fromname column
     *
     * Example usage:
     * <code>
     * $query->filterByFromname('fooValue');   // WHERE fromname = 'fooValue'
     * $query->filterByFromname('%fooValue%'); // WHERE fromname LIKE '%fooValue%'
     * </code>
     *
     * @param     string $fromname The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByFromname($fromname = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($fromname)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $fromname)) {
                $fromname = str_replace('*', '%', $fromname);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::FROMNAME, $fromname, $comparison);
    }

    /**
     * Filter the query on the mailfrom column
     *
     * Example usage:
     * <code>
     * $query->filterByMailfrom('fooValue');   // WHERE mailfrom = 'fooValue'
     * $query->filterByMailfrom('%fooValue%'); // WHERE mailfrom LIKE '%fooValue%'
     * </code>
     *
     * @param     string $mailfrom The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByMailfrom($mailfrom = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($mailfrom)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $mailfrom)) {
                $mailfrom = str_replace('*', '%', $mailfrom);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::MAILFROM, $mailfrom, $comparison);
    }

    /**
     * Filter the query on the smtphost column
     *
     * Example usage:
     * <code>
     * $query->filterBySmtphost('fooValue');   // WHERE smtphost = 'fooValue'
     * $query->filterBySmtphost('%fooValue%'); // WHERE smtphost LIKE '%fooValue%'
     * </code>
     *
     * @param     string $smtphost The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterBySmtphost($smtphost = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($smtphost)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $smtphost)) {
                $smtphost = str_replace('*', '%', $smtphost);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::SMTPHOST, $smtphost, $comparison);
    }

    /**
     * Filter the query on the smtpport column
     *
     * Example usage:
     * <code>
     * $query->filterBySmtpport(1234); // WHERE smtpport = 1234
     * $query->filterBySmtpport(array(12, 34)); // WHERE smtpport IN (12, 34)
     * $query->filterBySmtpport(array('min' => 12)); // WHERE smtpport > 12
     * </code>
     *
     * @param     mixed $smtpport The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterBySmtpport($smtpport = null, $comparison = null)
    {
        if (is_array($smtpport)) {
            $useMinMax = false;
            if (isset($smtpport['min'])) {
                $this->addUsingAlias(twSubscriptionListPeer::SMTPPORT, $smtpport['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($smtpport['max'])) {
                $this->addUsingAlias(twSubscriptionListPeer::SMTPPORT, $smtpport['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::SMTPPORT, $smtpport, $comparison);
    }

    /**
     * Filter the query on the smtpencr column
     *
     * Example usage:
     * <code>
     * $query->filterBySmtpencr(1234); // WHERE smtpencr = 1234
     * $query->filterBySmtpencr(array(12, 34)); // WHERE smtpencr IN (12, 34)
     * $query->filterBySmtpencr(array('min' => 12)); // WHERE smtpencr > 12
     * </code>
     *
     * @param     mixed $smtpencr The value to use as filter.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterBySmtpencr($smtpencr = null, $comparison = null)
    {
        if (is_array($smtpencr)) {
            $useMinMax = false;
            if (isset($smtpencr['min'])) {
                $this->addUsingAlias(twSubscriptionListPeer::SMTPENCR, $smtpencr['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($smtpencr['max'])) {
                $this->addUsingAlias(twSubscriptionListPeer::SMTPENCR, $smtpencr['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::SMTPENCR, $smtpencr, $comparison);
    }

    /**
     * Filter the query on the smtpuser column
     *
     * Example usage:
     * <code>
     * $query->filterBySmtpuser('fooValue');   // WHERE smtpuser = 'fooValue'
     * $query->filterBySmtpuser('%fooValue%'); // WHERE smtpuser LIKE '%fooValue%'
     * </code>
     *
     * @param     string $smtpuser The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterBySmtpuser($smtpuser = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($smtpuser)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $smtpuser)) {
                $smtpuser = str_replace('*', '%', $smtpuser);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::SMTPUSER, $smtpuser, $comparison);
    }

    /**
     * Filter the query on the smtppass column
     *
     * Example usage:
     * <code>
     * $query->filterBySmtppass('fooValue');   // WHERE smtppass = 'fooValue'
     * $query->filterBySmtppass('%fooValue%'); // WHERE smtppass LIKE '%fooValue%'
     * </code>
     *
     * @param     string $smtppass The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterBySmtppass($smtppass = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($smtppass)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $smtppass)) {
                $smtppass = str_replace('*', '%', $smtppass);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::SMTPPASS, $smtppass, $comparison);
    }

    /**
     * Filter the query on the website_base_url column
     *
     * Example usage:
     * <code>
     * $query->filterByWebsiteBaseUrl('fooValue');   // WHERE website_base_url = 'fooValue'
     * $query->filterByWebsiteBaseUrl('%fooValue%'); // WHERE website_base_url LIKE '%fooValue%'
     * </code>
     *
     * @param     string $websiteBaseUrl The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByWebsiteBaseUrl($websiteBaseUrl = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($websiteBaseUrl)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $websiteBaseUrl)) {
                $websiteBaseUrl = str_replace('*', '%', $websiteBaseUrl);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::WEBSITE_BASE_URL, $websiteBaseUrl, $comparison);
    }

    /**
     * Filter the query on the website_shared_key column
     *
     * Example usage:
     * <code>
     * $query->filterByWebsiteSharedKey('fooValue');   // WHERE website_shared_key = 'fooValue'
     * $query->filterByWebsiteSharedKey('%fooValue%'); // WHERE website_shared_key LIKE '%fooValue%'
     * </code>
     *
     * @param     string $websiteSharedKey The value to use as filter.
     *              Accepts wildcards (* and % trigger a LIKE)
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByWebsiteSharedKey($websiteSharedKey = null, $comparison = null)
    {
        if (null === $comparison) {
            if (is_array($websiteSharedKey)) {
                $comparison = Criteria::IN;
            } elseif (preg_match('/[\%\*]/', $websiteSharedKey)) {
                $websiteSharedKey = str_replace('*', '%', $websiteSharedKey);
                $comparison = Criteria::LIKE;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::WEBSITE_SHARED_KEY, $websiteSharedKey, $comparison);
    }

    /**
     * Filter the query on the lastsync_at column
     *
     * Example usage:
     * <code>
     * $query->filterByLastsyncAt('2011-03-14'); // WHERE lastsync_at = '2011-03-14'
     * $query->filterByLastsyncAt('now'); // WHERE lastsync_at = '2011-03-14'
     * $query->filterByLastsyncAt(array('max' => 'yesterday')); // WHERE lastsync_at > '2011-03-13'
     * </code>
     *
     * @param     mixed $lastsyncAt The value to use as filter.
     *              Values can be integers (unix timestamps), DateTime objects, or strings.
     *              Empty strings are treated as NULL.
     *              Use scalar values for equality.
     *              Use array values for in_array() equivalent.
     *              Use associative array('min' => $minValue, 'max' => $maxValue) for intervals.
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function filterByLastsyncAt($lastsyncAt = null, $comparison = null)
    {
        if (is_array($lastsyncAt)) {
            $useMinMax = false;
            if (isset($lastsyncAt['min'])) {
                $this->addUsingAlias(twSubscriptionListPeer::LASTSYNC_AT, $lastsyncAt['min'], Criteria::GREATER_EQUAL);
                $useMinMax = true;
            }
            if (isset($lastsyncAt['max'])) {
                $this->addUsingAlias(twSubscriptionListPeer::LASTSYNC_AT, $lastsyncAt['max'], Criteria::LESS_EQUAL);
                $useMinMax = true;
            }
            if ($useMinMax) {
                return $this;
            }
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }
        }

        return $this->addUsingAlias(twSubscriptionListPeer::LASTSYNC_AT, $lastsyncAt, $comparison);
    }

    /**
     * Filter the query by a related twSubscriptionListType object
     *
     * @param   twSubscriptionListType|PropelObjectCollection $twSubscriptionListType The related object(s) to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   twSubscriptionListQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBytwSubscriptionListType($twSubscriptionListType, $comparison = null)
    {
        if ($twSubscriptionListType instanceof twSubscriptionListType) {
            return $this
                ->addUsingAlias(twSubscriptionListPeer::TYPE_ID, $twSubscriptionListType->getId(), $comparison);
        } elseif ($twSubscriptionListType instanceof PropelObjectCollection) {
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }

            return $this
                ->addUsingAlias(twSubscriptionListPeer::TYPE_ID, $twSubscriptionListType->toKeyValue('PrimaryKey', 'Id'), $comparison);
        } else {
            throw new PropelException('filterBytwSubscriptionListType() only accepts arguments of type twSubscriptionListType or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the twSubscriptionListType relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function jointwSubscriptionListType($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('twSubscriptionListType');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'twSubscriptionListType');
        }

        return $this;
    }

    /**
     * Use the twSubscriptionListType relation twSubscriptionListType object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   twSubscriptionListTypeQuery A secondary query class using the current class as primary query
     */
    public function usetwSubscriptionListTypeQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->jointwSubscriptionListType($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'twSubscriptionListType', 'twSubscriptionListTypeQuery');
    }

    /**
     * Filter the query by a related twSubscriptionTemplate object
     *
     * @param   twSubscriptionTemplate|PropelObjectCollection $twSubscriptionTemplate The related object(s) to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   twSubscriptionListQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBytwSubscriptionTemplate($twSubscriptionTemplate, $comparison = null)
    {
        if ($twSubscriptionTemplate instanceof twSubscriptionTemplate) {
            return $this
                ->addUsingAlias(twSubscriptionListPeer::TEMPLATE_ID, $twSubscriptionTemplate->getId(), $comparison);
        } elseif ($twSubscriptionTemplate instanceof PropelObjectCollection) {
            if (null === $comparison) {
                $comparison = Criteria::IN;
            }

            return $this
                ->addUsingAlias(twSubscriptionListPeer::TEMPLATE_ID, $twSubscriptionTemplate->toKeyValue('PrimaryKey', 'Id'), $comparison);
        } else {
            throw new PropelException('filterBytwSubscriptionTemplate() only accepts arguments of type twSubscriptionTemplate or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the twSubscriptionTemplate relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function jointwSubscriptionTemplate($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('twSubscriptionTemplate');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'twSubscriptionTemplate');
        }

        return $this;
    }

    /**
     * Use the twSubscriptionTemplate relation twSubscriptionTemplate object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   twSubscriptionTemplateQuery A secondary query class using the current class as primary query
     */
    public function usetwSubscriptionTemplateQuery($relationAlias = null, $joinType = Criteria::LEFT_JOIN)
    {
        return $this
            ->jointwSubscriptionTemplate($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'twSubscriptionTemplate', 'twSubscriptionTemplateQuery');
    }

    /**
     * Filter the query by a related twSubscriptionEmail object
     *
     * @param   twSubscriptionEmail|PropelObjectCollection $twSubscriptionEmail  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   twSubscriptionListQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBytwSubscriptionEmail($twSubscriptionEmail, $comparison = null)
    {
        if ($twSubscriptionEmail instanceof twSubscriptionEmail) {
            return $this
                ->addUsingAlias(twSubscriptionListPeer::ID, $twSubscriptionEmail->getListId(), $comparison);
        } elseif ($twSubscriptionEmail instanceof PropelObjectCollection) {
            return $this
                ->usetwSubscriptionEmailQuery()
                ->filterByPrimaryKeys($twSubscriptionEmail->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBytwSubscriptionEmail() only accepts arguments of type twSubscriptionEmail or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the twSubscriptionEmail relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function jointwSubscriptionEmail($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('twSubscriptionEmail');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'twSubscriptionEmail');
        }

        return $this;
    }

    /**
     * Use the twSubscriptionEmail relation twSubscriptionEmail object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   twSubscriptionEmailQuery A secondary query class using the current class as primary query
     */
    public function usetwSubscriptionEmailQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->jointwSubscriptionEmail($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'twSubscriptionEmail', 'twSubscriptionEmailQuery');
    }

    /**
     * Filter the query by a related twSubscriptionListInvitation object
     *
     * @param   twSubscriptionListInvitation|PropelObjectCollection $twSubscriptionListInvitation  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   twSubscriptionListQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBytwSubscriptionListInvitation($twSubscriptionListInvitation, $comparison = null)
    {
        if ($twSubscriptionListInvitation instanceof twSubscriptionListInvitation) {
            return $this
                ->addUsingAlias(twSubscriptionListPeer::ID, $twSubscriptionListInvitation->getListId(), $comparison);
        } elseif ($twSubscriptionListInvitation instanceof PropelObjectCollection) {
            return $this
                ->usetwSubscriptionListInvitationQuery()
                ->filterByPrimaryKeys($twSubscriptionListInvitation->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBytwSubscriptionListInvitation() only accepts arguments of type twSubscriptionListInvitation or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the twSubscriptionListInvitation relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function jointwSubscriptionListInvitation($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('twSubscriptionListInvitation');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'twSubscriptionListInvitation');
        }

        return $this;
    }

    /**
     * Use the twSubscriptionListInvitation relation twSubscriptionListInvitation object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   twSubscriptionListInvitationQuery A secondary query class using the current class as primary query
     */
    public function usetwSubscriptionListInvitationQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->jointwSubscriptionListInvitation($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'twSubscriptionListInvitation', 'twSubscriptionListInvitationQuery');
    }

    /**
     * Filter the query by a related twSubscriptionMailing object
     *
     * @param   twSubscriptionMailing|PropelObjectCollection $twSubscriptionMailing  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   twSubscriptionListQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBytwSubscriptionMailing($twSubscriptionMailing, $comparison = null)
    {
        if ($twSubscriptionMailing instanceof twSubscriptionMailing) {
            return $this
                ->addUsingAlias(twSubscriptionListPeer::ID, $twSubscriptionMailing->getListId(), $comparison);
        } elseif ($twSubscriptionMailing instanceof PropelObjectCollection) {
            return $this
                ->usetwSubscriptionMailingQuery()
                ->filterByPrimaryKeys($twSubscriptionMailing->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBytwSubscriptionMailing() only accepts arguments of type twSubscriptionMailing or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the twSubscriptionMailing relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function jointwSubscriptionMailing($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('twSubscriptionMailing');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'twSubscriptionMailing');
        }

        return $this;
    }

    /**
     * Use the twSubscriptionMailing relation twSubscriptionMailing object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   twSubscriptionMailingQuery A secondary query class using the current class as primary query
     */
    public function usetwSubscriptionMailingQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->jointwSubscriptionMailing($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'twSubscriptionMailing', 'twSubscriptionMailingQuery');
    }

    /**
     * Filter the query by a related twSubscriptionMailQueue object
     *
     * @param   twSubscriptionMailQueue|PropelObjectCollection $twSubscriptionMailQueue  the related object to use as filter
     * @param     string $comparison Operator to use for the column comparison, defaults to Criteria::EQUAL
     *
     * @return   twSubscriptionListQuery The current query, for fluid interface
     * @throws   PropelException - if the provided filter is invalid.
     */
    public function filterBytwSubscriptionMailQueue($twSubscriptionMailQueue, $comparison = null)
    {
        if ($twSubscriptionMailQueue instanceof twSubscriptionMailQueue) {
            return $this
                ->addUsingAlias(twSubscriptionListPeer::ID, $twSubscriptionMailQueue->getListId(), $comparison);
        } elseif ($twSubscriptionMailQueue instanceof PropelObjectCollection) {
            return $this
                ->usetwSubscriptionMailQueueQuery()
                ->filterByPrimaryKeys($twSubscriptionMailQueue->getPrimaryKeys())
                ->endUse();
        } else {
            throw new PropelException('filterBytwSubscriptionMailQueue() only accepts arguments of type twSubscriptionMailQueue or PropelCollection');
        }
    }

    /**
     * Adds a JOIN clause to the query using the twSubscriptionMailQueue relation
     *
     * @param     string $relationAlias optional alias for the relation
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function jointwSubscriptionMailQueue($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        $tableMap = $this->getTableMap();
        $relationMap = $tableMap->getRelation('twSubscriptionMailQueue');

        // create a ModelJoin object for this join
        $join = new ModelJoin();
        $join->setJoinType($joinType);
        $join->setRelationMap($relationMap, $this->useAliasInSQL ? $this->getModelAlias() : null, $relationAlias);
        if ($previousJoin = $this->getPreviousJoin()) {
            $join->setPreviousJoin($previousJoin);
        }

        // add the ModelJoin to the current object
        if ($relationAlias) {
            $this->addAlias($relationAlias, $relationMap->getRightTable()->getName());
            $this->addJoinObject($join, $relationAlias);
        } else {
            $this->addJoinObject($join, 'twSubscriptionMailQueue');
        }

        return $this;
    }

    /**
     * Use the twSubscriptionMailQueue relation twSubscriptionMailQueue object
     *
     * @see       useQuery()
     *
     * @param     string $relationAlias optional alias for the relation,
     *                                   to be used as main alias in the secondary query
     * @param     string $joinType Accepted values are null, 'left join', 'right join', 'inner join'
     *
     * @return   twSubscriptionMailQueueQuery A secondary query class using the current class as primary query
     */
    public function usetwSubscriptionMailQueueQuery($relationAlias = null, $joinType = Criteria::INNER_JOIN)
    {
        return $this
            ->jointwSubscriptionMailQueue($relationAlias, $joinType)
            ->useQuery($relationAlias ? $relationAlias : 'twSubscriptionMailQueue', 'twSubscriptionMailQueueQuery');
    }

    /**
     * Exclude object from result
     *
     * @param   twSubscriptionList $twSubscriptionList Object to remove from the list of results
     *
     * @return twSubscriptionListQuery The current query, for fluid interface
     */
    public function prune($twSubscriptionList = null)
    {
        if ($twSubscriptionList) {
            $this->addUsingAlias(twSubscriptionListPeer::ID, $twSubscriptionList->getId(), Criteria::NOT_EQUAL);
        }

        return $this;
    }

} // BasetwSubscriptionListQuery